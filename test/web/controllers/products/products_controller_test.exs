defmodule ProjectOmeletteManager.ProductsController.Test do
  use ExUnit.Case
  use Plug.Test
  use ProjectOmeletteManager.Test.ConnHelper

  alias ProjectOmeletteManager.DB.Models.Product
  alias ProjectOmeletteManager.Router

  setup_all do
    :meck.new ProjectOmeletteManager.Repo

    on_exit fn -> :meck.unload end
  end

  test "index action" do
    products = [%Product{name: "test1"}, %Product{name: "test2"}]
    :meck.expect(ProjectOmeletteManager.Repo, :all, 1, products)

    conn = call(Router, :get, "/products")

    assert conn.status == 200

    body = Poison.decode!(conn.resp_body)

    assert length(body) == 2

    assert Enum.any?(body, &(&1["name"] == "test1"))
    assert Enum.any?(body, &(&1["name"] == "test2"))
  end

  test "show action - found" do
    product = %Product{name: "test1"}
    :meck.expect(ProjectOmeletteManager.Repo, :one, 1, product)

    conn = call(Router, :get, "/products/test1")

    assert conn.status == 200

    body = Poison.decode!(conn.resp_body)

    assert body["name"] == "test1"
  end

  test "show action -- not found" do
    :meck.expect(ProjectOmeletteManager.Repo, :one, 1, nil)

    conn = call(Router, :get, "/products/test1")

    assert conn.status == 404
  end

  test "create action -- success" do
    product = %Product{name: "test1", id: 1}
    :meck.expect(ProjectOmeletteManager.Repo, :one, 1, nil)
    :meck.expect(ProjectOmeletteManager.Repo, :insert, 1, product)

    conn = call(Router, :post, "/products", Poison.encode!(%{name: "test1"}), [{"content-type", "application/json"}])

    assert conn.status == 201

    assert List.keymember?(conn.resp_headers, "location", 0)

    {_, location} = List.keyfind(conn.resp_headers, "location", 0)

    assert "/products/test1" == location
  end

  test "create action -- fails on conflict" do
    product = %Product{name: "test1", id: 1}
    :meck.expect(ProjectOmeletteManager.Repo, :one, 1, product)

    conn = call(Router, :post, "/products", Poison.encode!(%{name: "test1"}), [{"content-type", "application/json"}])

    assert conn.status == 409
  end

  test "create action -- bad request on invalid product name" do
    :meck.expect(ProjectOmeletteManager.Repo, :one, 1, nil)

    conn = call(Router, :post, "/products", Poison.encode!(%{name: ""}), [{"content-type", "application/json"}])

    assert conn.status == 400
  end

  test "delete action -- success" do
    product = %Product{name: "test1", id: 1}
    :meck.expect(ProjectOmeletteManager.Repo, :one, 1, product)
    :meck.expect(ProjectOmeletteManager.Repo, :delete, 1, product)

    conn = call(Router, :delete, "/products/test1")

    assert conn.status == 204
  end

  test "delete action -- not found" do
    :meck.expect(ProjectOmeletteManager.Repo, :one, 1, nil)

    conn = call(Router, :delete, "/products/test1")

    assert conn.status == 404
  end

  test "update action -- success" do
    product = %Product{name: "original_test1", id: 1}
    updated_product = %Product{name: "updated_test1", id: 1}
    :meck.expect(ProjectOmeletteManager.Repo, :one, fn query ->

      # No real good way to get at the structure of the query, so just look at
      # the string generated by Kernel.inspect/1 and see if it's for the first
      # check or the second check.
      res = query
            |> inspect
            |> String.contains?("original_test1")

      if res, do: product, else: nil
    end)

    :meck.expect(ProjectOmeletteManager.Repo, :update, 1, updated_product)

    conn = call(Router, :put, "/products/original_test1", Poison.encode!(%{name: "updated_test1"}), [{"content-type", "application/json"}])

    assert conn.status == 204

    assert List.keymember?(conn.resp_headers, "location", 0)

    {_, location} = List.keyfind(conn.resp_headers, "location", 0)

    assert "/products/updated_test1" == location
  end

  test "update action -- not found" do
    :meck.expect(ProjectOmeletteManager.Repo, :one, 1, nil)

    conn = call(Router, :put, "/products/test1", Poison.encode!(%{name: "updated_test1"}), [{"content-type", "application/json"}])

    assert conn.status == 404
  end

  test "update action -- fails on invalid change" do
    product = %Product{name: "original_test1", id: 1}
    updated_product = %Product{name: "updated_test1", id: 1}
    :meck.expect(ProjectOmeletteManager.Repo, :one, fn query ->

      # No real good way to get at the structure of the query, so just look at
      # the string generated by Kernel.inspect/1 and see if it's for the first
      # check or the second check.
      res = query
            |> inspect
            |> String.contains?("original_test1")

      if res, do: product, else: nil
    end)

    conn = call(Router, :put, "/products/original_test1", Poison.encode!(%{name: ""}), [{"content-type", "application/json"}])

    assert conn.status == 400
  end

  test "update action -- fails on conflicting name" do
    product1 = %Product{name: "original_test1", id: 1}
    product2 = %Product{name: "updated_test1", id: 2}

    :meck.expect(ProjectOmeletteManager.Repo, :one, fn query ->

      # No real good way to get at the structure of the query, so just look at
      # the string generated by Kernel.inspect/1 and see if it's for the first
      # check or the second check.
      res = query
            |> inspect
            |> String.contains?("original_test1")

      if res, do: product1, else: product2
    end)

    conn = call(Router, :put, "/products/original_test1", Poison.encode!(%{name: ""}), [{"content-type", "application/json"}])

    assert conn.status == 400
  end
end